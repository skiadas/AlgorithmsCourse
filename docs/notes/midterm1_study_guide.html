<!DOCTYPE html>
<html>
<head>
  <link href='https://fonts.googleapis.com/css?family=Roboto:400,700' rel='stylesheet' type='text/css'>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet" href="https://skiadas.github.io/css/course.css" type="text/css" />
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>
<body>
<h1 id="midterm-1-study-guide">Midterm 1 Study Guide</h1>
<p>This midterm covers chapters 1 through 4. Here is a list of the main ideas:</p>
<ol style="list-style-type: decimal">
<li>What constitutes an <em>algorithm</em>?</li>
<li>What questions might the <em>analysis</em> of an algorithm entail?</li>
<li>Be able to explain what stable and in-place sorting is, and which of the sorting algorithms we have seen have those properties.</li>
<li>Describe the two different ways of representing graphs.</li>
<li>Be able to compare the following functions in terms of their order of growth: <span class="math inline">\(\log_2n\)</span>, <span class="math inline">\(\log_{10}n\)</span>, <span class="math inline">\(n\)</span>, <span class="math inline">\(n^2\)</span>, <span class="math inline">\(2n\)</span>, <span class="math inline">\(n\log n\)</span>, <span class="math inline">\(1000n\)</span>, <span class="math inline">\(2^n\)</span>, <span class="math inline">\(10^n\)</span>, <span class="math inline">\(n!\)</span></li>
<li>Explain the main ideas behind <span class="math inline">\(O\)</span>, <span class="math inline">\(\Theta\)</span> and <span class="math inline">\(\Omega\)</span>.</li>
<li>Be able to determine the time efficiency for non-recursive algorithms by setting up a sum formula and then computing it.</li>
<li>Be able to determine the time efficiency for recursive algorithms by setting up a recursive relation and then solving it.</li>
<li>For each of the following algorithms be able to write pseudocode, identify the basic operation and input size, determine best-case and worst-case complexity, and completely carry out a small-size example:
<ul>
<li>Counting sort</li>
<li>Selection sort</li>
<li>Bubble sort</li>
<li>Insertion sort</li>
<li>Brute-force traveling salesman</li>
<li>Depth-first search</li>
<li>Breadth-first search</li>
<li>Topological sort</li>
<li>Binary search</li>
</ul></li>
</ol>
</body>
</html>
